import subprocess
import os
import shutil
from pathlib import Path
from agent.base import IPsecBackend
from agent.config_schema import AgentConfig

class LinuxAgent(IPsecBackend):
    def __init__(self, config: AgentConfig, base_dir: Path, logger):
        super().__init__(config, base_dir, logger)
        self.conf_dir = Path("/etc/swanctl/conf.d")
        
        # Default to local output directory if /etc/swanctl doesn't exist (e.g. dev environment)
        if not self.conf_dir.exists():
            self.conf_dir = self.base_dir / "output" / "swanctl"
            self.conf_dir.mkdir(parents=True, exist_ok=True)

    def _generate_swanctl_conf(self) -> str:
        """Generates swanctl.conf content based on config."""
        
        conf_lines = ["# Generated by Unified IPsec Agent"]
        conf_lines.append("connections {")
        
        for conn in self.config.connections:
            # Defaults
            ike_prop = conn.encryption.ike if conn.encryption.ike != "default" else "aes256-sha256-modp2048"
            esp_prop = conn.encryption.esp if conn.encryption.esp != "default" else "aes256-sha256"
            
            # Traffic Selectors
            # Format: subnet[proto/port]
            # e.g. 10.0.0.0/24[tcp/80]
            
            proto = conn.protocol.lower()
            if proto == "any": proto_str = ""
            else: proto_str = f"{proto}"
            
            # Ports
            # Swanctl expects: [udp/500], [tcp], [6] (protocol number)
            # If port provided, we need protocol.
            
            def format_ts(subnets, port):
                ts_list = []
                for s in subnets:
                    if port != "any":
                        # If port is set, assuming protocol is set or default to tcp/udp logic?
                        # Config schema defaults protocol to "any".
                        # StrongSwan requires protocol for port.
                        p_str = proto if proto != "any" else "tcp" # Defaulting to tcp if port set but proto any? Or explicit validation needed.
                        ts_list.append(f"{s}[{p_str}/{port}]")
                    elif proto != "any":
                         ts_list.append(f"{s}[{proto}]")
                    else:
                        ts_list.append(s)
                return ",".join(ts_list)

            local_ts = format_ts(conn.local_subnets, conn.local_port)
            remote_ts = format_ts(conn.remote_subnets, conn.remote_port)
            
            # IDs usually based on first IP or explicit ID if we added that field
            local_id = conn.local_subnets[0].split('/')[0]
            remote_id = conn.remote_subnets[0].split('/')[0]

            conf_lines.append(f"""

    {conn.name} {{
        local_addrs = {local_id} 
        remote_addrs = {remote_id} 
        
        local {{
            auth = {conn.auth.type}
            id = {local_id}
        }}
        remote {{
            auth = {conn.auth.type}
            id = {remote_id}
        }}
        
        children {{
            {conn.name}-child {{
                local_ts = {local_ts}
                remote_ts = {remote_ts}
                mode = {conn.mode}
                esp_proposals = {esp_prop}
                start_action = start
                dpd_action = restart
                dpd_delay = 30s
            }}
        }}
        version = {2 if conn.ike_version == "ikev2" else 1}
        proposals = {ike_prop}
        dpd_delay = 30s
        dpd_timeout = 120s
    }}""")
        
        conf_lines.append("}\n") # End connections

        conf_lines.append("secrets {")
        for conn in self.config.connections:
            local_id = conn.local_subnets[0].split('/')[0]
            remote_id = conn.remote_subnets[0].split('/')[0]
            conf_lines.append(f"""
    ike-{conn.name} {{
        secret = "{conn.auth.value}" 
        id-a = {local_id}
        id-b = {remote_id}
    }}""")
        conf_lines.append("}\n")

        return "\n".join(conf_lines)

    def apply_policy(self) -> bool:
        self.logger.info("Generating StrongSwan configuration (swanctl)...")
        
        try:
            conf_content = self._generate_swanctl_conf()
            conf_file = self.conf_dir / "agent.conf"
            
            self.logger.info(f"Writing config to {conf_file}")
            with open(conf_file, "w") as f:
                f.write(conf_content)
                
            # If we are on actual Linux and have swanctl implementation
            if shutil.which("swanctl"):
                self.logger.info("Reloading swanctl...")
                # swanctl --load-all
                subprocess.run(["swanctl", "--load-all"], check=True)
                
                self.logger.info("Initiating connections...")
                for conn in self.config.connections:
                    child_name = f"{conn.name}-child"
                    self.logger.info(f"Initiating {child_name}...")
                    subprocess.run(["swanctl", "--initiate", "--child", child_name], check=False)
            else:
                self.logger.warning("swanctl command not found. Config generated but not loaded (Expected if running on Windows).")
            
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to apply Linux policy: {e}")
            return False

    def check_status(self) -> str:
        # Check swanctl --list-sas
        if shutil.which("swanctl"):
            try:
                res = subprocess.run(["swanctl", "--list-sas", "--output", "json"], capture_output=True, text=True)
                # Parse JSON if possible, or just look for ANY active child SA
                # Simple loose verification: if output contains "child-sa", likely something is up.
                # Or check if any of our configured connection names are present as established.
                if "home" in res.stdout or "child-" in res.stdout: 
                     # Better: parse json? 
                     # For prototype, string matching "INSTALLED" or "ESTABLISHED" is safer.
                     # swanctl output usually says "state": "ESTABLISHED"
                     if "ESTABLISHED" in res.stdout or "INSTALLED" in res.stdout:
                         return "CONNECTED"
            except:
                pass
        return "DISCONNECTED"

    def cleanup(self):
        self.logger.info("Cleaning up swanctl config...")
        conf_file = self.conf_dir / "agent.conf"
        if conf_file.exists():
            os.remove(conf_file)
        # Reload to clear
        if shutil.which("swanctl"):
             subprocess.run(["swanctl", "--load-all"], check=False)

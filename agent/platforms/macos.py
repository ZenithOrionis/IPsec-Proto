import subprocess
import os
import shutil
from pathlib import Path
from agent.base import IPsecBackend
from agent.config_schema import AgentConfig

class MacOSAgent(IPsecBackend):
    def __init__(self, config: AgentConfig, base_dir: Path, logger):
        super().__init__(config, base_dir, logger)
        
        # Homebrew paths for StrongSwan
        # Intel Mac: /usr/local/etc/swanctl
        # Apple Silicon: /opt/homebrew/etc/swanctl
        
        possible_paths = [
            Path("/opt/homebrew/etc/swanctl/conf.d"),
            Path("/usr/local/etc/swanctl/conf.d")
        ]
        
        self.conf_dir = None
        for p in possible_paths:
            if p.exists():
                self.conf_dir = p
                self.logger.info(f"Detected StrongSwan config dir at: {p}")
                break
        
        if not self.conf_dir:
            # Fallback for local development
            self.conf_dir = self.base_dir / "output" / "macos_swanctl"
            self.conf_dir.mkdir(parents=True, exist_ok=True)
            self.logger.warning("StrongSwan config dir not found. Using local output dir for config generation.")

    def _generate_swanctl_conf(self) -> str:
        """Generates swanctl.conf content based on config."""
        
        conf_lines = ["# Generated by Unified IPsec Agent (MacOS)"]
        conf_lines.append("connections {")
        
        for conn in self.config.connections:
            # Defaults
            ike_prop = conn.encryption.ike if conn.encryption.ike != "default" else "aes256-sha256-modp2048"
            esp_prop = conn.encryption.esp if conn.encryption.esp != "default" else "aes256-sha256"
            
            # Traffic Selectors
            proto = conn.protocol.lower()
            
            def format_ts(subnets, port):
                ts_list = []
                for s in subnets:
                    if port != "any":
                        p_str = proto if proto != "any" else "tcp" 
                        ts_list.append(f"{s}[{p_str}/{port}]")
                    elif proto != "any":
                         ts_list.append(f"{s}[{proto}]")
                    else:
                        ts_list.append(s)
                return ",".join(ts_list)

            local_ts = format_ts(conn.local_subnets, conn.local_port)
            remote_ts = format_ts(conn.remote_subnets, conn.remote_port)
            
            local_id = conn.local_subnets[0].split('/')[0]
            remote_id = conn.remote_subnets[0].split('/')[0]

            conf_lines.append(f"""
    {conn.name} {{
        local_addrs = {local_id} 
        remote_addrs = {remote_id} 
        
        local {{
            auth = {conn.auth.type}
            id = {local_id}
        }}
        remote {{
            auth = {conn.auth.type}
            id = {remote_id}
        }}
        
        children {{
            {conn.name}-child {{
                local_ts = {local_ts}
                remote_ts = {remote_ts}
                mode = {conn.mode}
                esp_proposals = {esp_prop}
                start_action = start
                dpd_action = restart
                dpd_delay = 30s
            }}
        }}
        version = {2 if conn.ike_version == "ikev2" else 1}
        proposals = {ike_prop}
        dpd_delay = 30s
        dpd_timeout = 120s
    }}""")
        
        conf_lines.append("}\n") # End connections

        conf_lines.append("secrets {")
        for conn in self.config.connections:
            local_id = conn.local_subnets[0].split('/')[0]
            remote_id = conn.remote_subnets[0].split('/')[0]
            conf_lines.append(f"""
    ike-{conn.name} {{
        secret = "{conn.auth.value}" 
        id-a = {local_id}
        id-b = {remote_id}
    }}""")
        conf_lines.append("}\n")

        return "\n".join(conf_lines)

    def apply_policy(self) -> bool:
        self.logger.info("Generating StrongSwan configuration for macOS...")
        
        try:
            conf_content = self._generate_swanctl_conf()
            conf_file = self.conf_dir / "agent.conf"
            
            self.logger.info(f"Writing config to {conf_file}")
            with open(conf_file, "w") as f:
                f.write(conf_content)
                
            # Reload
            # Need to find swanctl binary
            swanctl_bin = shutil.which("swanctl")
            if not swanctl_bin:
                # Check brew paths
                for p in ["/opt/homebrew/sbin/swanctl", "/usr/local/sbin/swanctl"]:
                    if os.path.exists(p):
                        swanctl_bin = p
                        break
            
            if swanctl_bin:
                self.logger.info(f"Reloading swanctl using {swanctl_bin}...")
                subprocess.run([swanctl_bin, "--load-all"], check=True)
                self.logger.info("Initiating connections...")
                for conn in self.config.connections:
                     child_name = f"{conn.name}-child"
                     subprocess.run([swanctl_bin, "--initiate", "--child", child_name], check=False)
            else:
                self.logger.warning("swanctl binary not found. Config generated but not loaded.")
            
            return True
            
        except Exception as e:
            self.logger.error(f"Failed to apply macOS policy: {e}")
            return False

    def check_status(self) -> str:
        swanctl_bin = shutil.which("swanctl")
        if not swanctl_bin:
             for p in ["/opt/homebrew/sbin/swanctl", "/usr/local/sbin/swanctl"]:
                    if os.path.exists(p):
                        swanctl_bin = p
                        break
        
        if swanctl_bin:
            try:
                res = subprocess.run([swanctl_bin, "--list-sas", "--output", "json"], capture_output=True, text=True)
                if "ESTABLISHED" in res.stdout or "INSTALLED" in res.stdout:
                    return "CONNECTED"
            except:
                pass
        return "DISCONNECTED"

    def cleanup(self):
        self.logger.info("Cleaning up macOS swanctl config...")
        conf_file = self.conf_dir / "agent.conf"
        if conf_file.exists():
            os.remove(conf_file)
        
        # Reload
        swanctl_bin = shutil.which("swanctl")
        if swanctl_bin:
             subprocess.run([swanctl_bin, "--load-all"], check=False)
